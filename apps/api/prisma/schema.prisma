// Prisma schema file
// https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
}

model Song {
  id              String                      @id @default(uuid()) @db.Uuid
  title           String
  artist          String
  album           String?
  year            Int?
  popularity      Int                         @default(0)
  tags            String[]                    @default([])
  phrases         String[]                    @default([])
  mbid            String?                     @unique
  isrc            String?                     @unique @db.VarChar(12)
  source          String?                     @default("manual")
  sourceUrl       String?                     @map("source_url")
  embeddingVector  Unsupported("vector(384)")? @map("embedding_vector")
  embeddingVersion Int                          @default(1) @map("embedding_version")
  isPlaceholder    Boolean                      @default(false) @map("is_placeholder")
  importBatchId      String?                     @db.Uuid @map("import_batch_id")
  primaryArtist      String?                     @map("primary_artist")
  primaryArtistMbid  String?                     @map("primary_artist_mbid")
  artistCredit       String?                     @map("artist_credit")
  createdAt          DateTime                    @default(now())
  updatedAt          DateTime                    @updatedAt

  messages  Message[]
  aboutness SongAboutness?

  @@index([tags], map: "idx_songs_tags", type: Gin)
  @@index([phrases], map: "idx_songs_phrases", type: Gin)
  @@index([title, artist], map: "idx_songs_title_artist")
  @@index([popularity], map: "idx_songs_popularity")
  @@index([year], map: "idx_songs_year")
  @@index([isPlaceholder], map: "idx_songs_is_placeholder")
  @@index([importBatchId], map: "idx_songs_import_batch_id")
  @@index([primaryArtistMbid], map: "idx_songs_primary_artist_mbid")
  // Note: HNSW index on embedding_vector created via raw SQL (idx_songs_embedding_hnsw)
  // Note: Unique index on ISRC created via raw SQL (idx_songs_isrc)
  @@map("songs")
}

model Message {
  id               String   @id @default(uuid()) @db.Uuid
  userId           String   @db.Uuid
  roomId           String   @db.Uuid
  text             String
  chosenSongId     String?  @db.Uuid
  scores           Json?
  replyToMessageId String?  @db.Uuid
  createdAt        DateTime @default(now())

  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  room           Room              @relation(fields: [roomId], references: [id], onDelete: Cascade)
  song           Song?             @relation(fields: [chosenSongId], references: [id])
  replyToMessage Message?          @relation("MessageReplies", fields: [replyToMessageId], references: [id], onDelete: SetNull)
  replies        Message[]         @relation("MessageReplies")
  reactions      MessageReaction[]

  @@index([userId], map: "idx_messages_user_id")
  @@index([roomId], map: "idx_messages_room_id")
  @@index([chosenSongId], map: "idx_messages_song_id")
  @@index([createdAt], map: "idx_messages_created_at")
  @@index([replyToMessageId], map: "idx_messages_reply_to_message_id")
  @@map("messages")
}

model User {
  id         String   @id @default(uuid()) @db.Uuid
  anonHandle String   @unique
  ipHash     String
  createdAt  DateTime @default(now())

  messages  Message[]
  reactions MessageReaction[]

  @@index([anonHandle], map: "idx_users_anon_handle")
  @@index([ipHash], map: "idx_users_ip_hash")
  @@index([createdAt], map: "idx_users_created_at")
  @@map("users")
}

model Room {
  id            String   @id @default(uuid()) @db.Uuid
  name          String   @unique
  allowExplicit Boolean  @default(false)
  createdAt     DateTime @default(now())

  messages Message[]

  @@index([name], map: "idx_rooms_name")
  @@index([createdAt], map: "idx_rooms_created_at")
  @@map("rooms")
}

model SongAboutness {
  songId           String                      @id @db.Uuid @map("song_id")

  // V2 fields (emotions + moments, OpenAI-generated)
  emotionsText       String?                     @map("emotions_text")
  emotionsVector     Unsupported("vector(384)")? @map("emotions_vector")
  emotionsConfidence String?                     @map("emotions_confidence")
  momentsText        String?                     @map("moments_text")
  momentsVector      Unsupported("vector(384)")? @map("moments_vector")
  momentsConfidence  String?                     @map("moments_confidence")
  provider           String?                     @map("provider")
  generationModel    String?                     @map("generation_model")

  // Legacy V1 fields — kept for compatibility, no longer written after V2 backfill
  aboutnessText    String                      @map("aboutness_text")
  aboutnessJson    Json                        @map("aboutness_json")
  aboutnessVector  Unsupported("vector(384)")? @map("aboutness_vector")
  aboutnessVersion Int                         @map("aboutness_version")
  embeddingModel   String                      @map("embedding_model")
  generatedAt      DateTime                    @map("generated_at") @db.Timestamptz

  song Song @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([aboutnessVersion], map: "idx_song_aboutness_version")
  // HNSW indexes created via raw SQL:
  //   idx_song_aboutness_hnsw         — on aboutness_vector (legacy V1)
  //   idx_song_aboutness_emotions_hnsw — on emotions_vector (V2, cosine)
  @@map("song_aboutness")
}

model MessageReaction {
  id        String   @id @default(uuid()) @db.Uuid
  messageId String   @db.Uuid
  userId    String   @db.Uuid
  emoji     String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@map("message_reactions")
}